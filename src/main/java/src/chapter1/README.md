### 1챕터 초반의 코드는 무엇이 문제인가
1. 실행 중에 제대로 동작하는 것
코드는 관람객이 돈이 없는 경우 등 예외 처리가 되어있지 않다.

2. 변경에 유연해야 한다.
각 객체 간의 의존성 분리가 안되어 있다. Theater안에서 직접 접근하고 있는 Audience, Bag가 수정된다면, 연쇄적으로 영향을 주어 Theater까지 영향을 미친다.

3. 코드를 읽는 사람과 의사소통하는 것
객체 지향 코드는 현실 세계와 유사하게 설계되어, 사용자도 유추 가능하게 설계해야 한다.
   (조금 단편적인 예시지만 만약 에러가 났을 때, 현실 세계와 비슷하게 설계된다면 이해하기 더 수월할 수 있다고 생각했다.)


**캡슐화란?**

개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것
이로 인해 객체는 내부에서 수행되는 일을 외부에 공개하지 않음으로 주어진 일을 스스로 수행하게 강제할 수 있다.


**어떻게 하면 의존성을 줄일 수 있는가?**

객체가 자신의 문제를 스스로 해결하도록 코드를 변경한 것이다.
내 생각: 하지만 실제 미션에서는 이것을 판단하기 쉽지 않았다. 현재는 어디까지가 해당 객체의 역할인지 논리적인 기준을 가지고 선택하는 것이 좋은 방향이라고 생각하고 있다.

**응집도란?**

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 정도

**절차적 프로그래밍**

프로세스와 데이터를 별도의 모듈에 위치시키는 방식이다.
내 생각: 각 객체의 역할과 책임을 가지고 협력하는 것이 아니라, 데이터 따로 프로세스 따로인 모듈을 가지고 실행시키는 것 같다.



## 책 안보고 다시 리팩토링

### 리팩토링 결과
TicketSeller가 Audience에게 초대권이 있는지 물어본다.
만약 있다면, Audience에게 TicketOffice에서 getTickets()를 해온 후 changeInvitation()에 전달하여 실행시킨다.
+ changeInvitation()는 bag에게 메세지를 보내어 초대권을 제거한 후, 입력 받은 Ticket을 저장한다.

없다면 TicketOffice에서 getTickets()로 Ticket을 가져와 입력한 후, Audience에게 buy()메세지를 보낸다.
그럼 Audience는 bag에게 메세지를 보내어 Ticket을 구매한다.

### 책과 차이

TicketSeller에서 아래의 흐름을 실행시킨다.
audience가 tickOffice에서 getTickets()해온 값을 입력 받아 구매한 후, 구입한 금액을 반환한다.

이때 구입한 금액을 받아오는 과정도 신기하다.
bag에게 물어본다.
만약 초대권이 있으면 0원을 리턴하고
초대권이 없다면 구매한 후에 티켓 가격을 리턴한다.
-> 이게 진짜 객체의 협력 아닐까?? 난 왜 이 생각을 못했을까...?

audience가 buy를 하면서 리턴한 구매 가격을 ticketOffce의 plusAmount를 통해 수익을 추가한다.



### 토론 거리
Bag의 hold는 적합한 이름인가?
hold의 역할
교환권이 있는지 확인 후, 존재한다면 입력 받은 Ticket을 그대로 저장한 후 0원을 리턴한다.
존재하지 않는다면 입력 받은 티켓의 가격 만큼 돈을 지불한 후, 티켓의 가격을 리턴한다.


이런 경우면 exchangeTicket()으로 했을 것 같다. 만약 이 이름으로 했다면 다른 사람들은 이해가 잘 될까?
